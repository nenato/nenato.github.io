<!DOCTYPE html>
<html>
<head>
  <title>Exercise</title>
  <style>
    canvas {
      width: 800px;
      height: 800px;
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <h1>Exercise</h1>
  <canvas id="graphCanvas" width="800" height="800">
    Your browser does not support the canvas element.
  </canvas>
  <h1>Segments</h1>
  <div id="segmentsList">

  </div>
  <div id="message">

  </div>
  <script>
    // half the width and height of the canvas
    canvasOffset = canvasOffsetX = 400;
    canvasOffsetY = 400;

    var segments = [];

    function writeToCanvas(text, context, coordinates) {
      context.font = "bold 16px Arial";
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, coordinates[0]+30, coordinates[1]);      
    }

    function plotCircle(coordinates, description="", color="black", radius=2) {
      var canvas = document.getElementById("graphCanvas");
      var context = canvas.getContext("2d");
      context.beginPath();
      context.arc(coordinates[0], coordinates[1], radius, 0, 2 * Math.PI, false);
      context.fillStyle = color;
      context.fill();
      writeToCanvas(description, context, coordinates);
      context.stroke();
    }

    function plotXY() {
      var canvas = document.getElementById("graphCanvas");
      var context = canvas.getContext("2d");
      context.beginPath();     
      context.moveTo(400, 0);
      context.lineTo(400, 800);
      context.stroke();

      context.beginPath();     
      context.moveTo(0, 400);
      context.lineTo(800, 400);
      context.stroke();
    }

    plotXY();

    function plotPolyline(coordinatesArray) {

      var canvas = document.getElementById("graphCanvas");
      var context = canvas.getContext("2d");
      context.beginPath();

      var start = toCanvas(coordinatesArray[0]);
      plotCircle(start, "start");

      var end = toCanvas(coordinatesArray[coordinatesArray.length-1]);
      plotCircle(end, "end");

      context.moveTo(coordinatesArray[0][0]+canvasOffsetX, (-1*coordinatesArray[0][1])+canvasOffsetY);
      for (var i = 1; i < coordinatesArray.length; i++) {
        segments.push([coordinatesArray[i-1], coordinatesArray[i]]);
        var pos = coordinatesArray[i];
        pos = toCanvas(pos);
        context.lineTo(pos[0], pos[1]);
      }
      context.stroke();

      for (var i = 1; i < coordinatesArray.length -1; i++) {
        var pos = coordinatesArray[i];
        pos = toCanvas(pos);
        plotCircle(pos, i);
      }
      
    }
    // canvas starts at 0,0 in the top left corner, so we have to fix it
    function toCanvas(pos) {
      return [pos[0]+canvasOffsetX, -1*(pos[1])+canvasOffsetY];  // TODO: multiply y by -1
    }

    // makes my life easier when thinking about the coordinates
    function toCartesian(pos) {
      return [pos[0]-canvasOffsetX, pos[1]-canvasOffsetY];
    }
  
    function calculateDistance(point, segment) {

      a = segment[0];
      b = segment[1];

      gradient = (a[1]-b[1])/(a[0]-b[0]);
      console.log("gradient", gradient);

      // equacao fundamental da reta mas
      // usando a formula do gradiente (coeficiente angular) junto
      // (m * x) - (m * x1) - y + y1) = 0

      distance = Math.abs((gradient * point[0]) - (gradient * a[0]) - point[1] + a[1]) / Math.sqrt(gradient**2 + 1);
      console.log(distance);
      return Math.abs(distance);
    }
  
    // used to calculate the station of each segment from start
    function calculateHypotenuse(segment) {
      a = segment[0];
      b = segment[1];
      console.log("calculating",a,b)

      return Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2);
    }

    // used to calculate the station of the segment that is interrupted by the point
    function calculateCathetus(offset, point, beginingOfLastSegment) {
      // this segment is from point to begining of last segment
      hypotenuse = calculateHypotenuse([point, beginingOfLastSegment]);
      console.log("hyp", hypotenuse);

      // result is the desired cathethus
      return Math.sqrt(((hypotenuse)**2) - ((offset)**2));
    }

    // from input.csv, but only half of it to be an actual line
    var coordinatesArray = [
      [-173,-237],
      [-139,-79],
      [-46,-29],
      [53,31],
      [114,45],
      [128,101],
      [229,152],
      [312,166],
    ];

    plotPolyline(coordinatesArray);

    point = [150, 200];
    plotCircle(toCanvas(point), "input");

    var segmentsListDOM = document.getElementById("segmentsList");
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];

      distance = calculateDistance(point, segment);
      station = calculateCathetus(distance, point, segment[0]);

      var segmentDOM = document.createElement("div");
      segmentDOM.innerHTML = "Segment " + (i+1) + ": " + segment[0] + " â€” " + segment[1] + " d = " + distance + " s = " + station;
      segmentsListDOM.appendChild(segmentDOM);

      var msg = document.getElementById("message");
      msg.innerHTML = "station = " + calculateCathetus(distance, point, segment[0]) + "<br>";
      msg.innerHTML += "hypotenuse = " + calculateHypotenuse(segment);
    }

    closestSegmentIndex = 0;
    closestSegment = segments[0];
    closestDistance = 0;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      distance = calculateDistance(point, segment);
      if (distance < calculateDistance(point, closestSegment)) {
        closestSegment = segment;
        closestSegmentIndex = i;
        closestDistance = distance;
      }
    }
    station = 0;
    for (var i = 0; i < closestSegmentIndex-1; i++) {
      station += calculateHypotenuse(segments[i]);
    }
    station += calculateCathetus(distance, point, segment[0]);
    console.log("closest segment", closestSegment);
    console.log("closest distance", closestDistance);
    console.log("station", station)

  </script>
</body>
</html>